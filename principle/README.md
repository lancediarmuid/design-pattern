## 面向对象编程的优势
1. 更加能够应对大规模复杂程序的开发
2. 更易复用、易扩展、易维护
3. 更加人性化、更加高级、更加智能

## 反OO编程：
1. 滥用getter、setter方法
2. 滥用全局变量和全局方法
   1. 集中存放静态常量到一个类中，存在的问题：
      1. 影响代码的可维护性，提高了提交代码冲突的概率；
      2. 增加代码的编译时间，影响开发效率；
      3. 影响代码的复用性
3. 定义数据和方法分离的类
   1. 日常常用的 MVC web 开发模式称之为：基于贫血模型的开发模式
   2. 什么是贫血模型：
      1. 贫血模型（Anemic Domain Model由
MatinFowler提出）又称为失血模型，是指domain object仅有属性的getter/setter方法的纯数据类，将所有类的行为放到service层。原文他是这么说的“By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring. ”他的原文我放上来了，英文好的同学可以看看：https://martinfowler.com/bliki/AnemicDomainModel.html 。 我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don't know why this anti-pattern is so common）。

## 抽象类跟接口的区别是什么
1. 抽象类的特征：
   1. 抽象类不允许被实例化，只能被继承；
   2. 抽象类可以包含属性和方法；
   3. 子类继承抽象类，必须实现抽象类中的所有抽象方法。
2. 接口类的特征：
   1. 接口不能包含属性；
   2. 接口只能声明方法，方法不能包含代码实现；
   3. 类实现接口的时候，必须实现接口中声明的所有方法；
3. 抽象类解决的问题：
   1. 抽象类更侧重于解决代码复用性的问题；
   2. 接口类更侧重与解决代码解耦，提高代码的可扩展性；
4. 使用场景的区别：
   1. 如果要表示一种is-a的关系的时候，使用抽象类，解决代码复用性问题；
   2. 如果要表示一种has-a的关系的时候，使用接口，解决抽象问题；

## 为什么基于接口而非实现编程（是否有必要为每个类都定义接口）？
1. 应该是不需要为每个类都定义接口的，不应该过度使用这条原则，到时候接口满天飞，会导致不必要的开发负担。
2. 这条原则的初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。降低代码之间的耦合性，提高代码的扩展性。
3. *越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完以后，基本不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。*

## 设计原则实践
1. 基于接口而非实现编程。
   1. 这条原则可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。
   2. 好处：
      1. 能够非常有效地提高代码质量
      2. 降低耦合性，提高扩展性
   3. 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。
   4. 实践要点：
      1. 函数的命名不能暴露任何实现细节。
      2. 封装具体的实现细节。
      3. 为实现类定义抽象的接口。
   5. 总结：
      1. 做软件开发的时候，一定要有抽象意识、封装意识、接口意识。
      2. 在定义接口的时候，不要暴露任何实现细节。
      3. 接口的定义只表明做什么，而不是怎么做。
      4. 在设计接口的时候，要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。
2. 多用组合少用继承。(即：组合优于继承)
   1. 继承存在的问题：
      1. 继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。
      2. 如果过度使用组合，以为着要做更细粒度的类的拆分，就要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。
   2. 如何判断改用组合还是继承：
      1. 如果类之间的继承结构稳定（不轻易改变），继承层次比较浅，继承关系不复杂，此时应当推荐使用继承。
      2. 如果系统接口不稳定，继承层次很深，继承关系复杂，此时应当推荐使用组合。




### 备注
- 委托：
```java

public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
```