## 为什么要解耦
1. 有利于保证代码松耦合、高内聚；
2. 有利于保证保证代码质量不至于腐化到无可救药的地步；
3. “高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，让我们的焦点不至于过于发散，降低阅读和修改代码的难度。
4. 降低引入bug的风险
5. 代码可测试性好
6. 代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合度小，有效地降低了重构的难度

## 如何判断是否需要解耦
1. 把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构

## 如何给代码解耦
1. 封装与抽象
   - 可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且一用的抽象接口。
2. 引入中间层
   - ![](./pics/17-1.jpg)
   - 引入中间层能简化模块或类之间的依赖关系。如上图依赖对比图所示。
   - 在进行重构的时候，引入中间层可以起到过度的作用，能够让开发和重构同步进行，互不干扰。
   - 为了让重构小步快跑，可以分下面四个阶段来完成接口的修改：
     1. 引入一个中间层，包裹老的接口，提供新的接口定义；
     2. 新开发的代码依赖中间层提供的新接口；
     3. 将依赖老街口的代码改为调用新接口；
     4. 确保所有的代码都调用新接口之后，删除掉老接口；
3. 模块化
   - 模块化是构建复杂系统常用的手段；
   - 对于一个大型复杂系统来说，没有人能掌控所有的细节。
   - 聚焦到软件开发层面，不同模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。
   - 聚焦到代码层面，合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。
   - **追本溯源，模块化思想更加本质的东西就是分而治之。**
4. 以“高内聚、松耦合”为目的的其他设计思想和原则
   - 单一职责原则
   - 基于接口而非实现编程
   - 依赖注入
   - 多用组合少用继承
   - 迪米特法则