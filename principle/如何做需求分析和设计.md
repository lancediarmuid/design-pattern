> 对于一个工程师来说，如果要追求长远发展，你就不能一直吧自己放在执行者的角色，不能只是一个代码实现者，你还要有独立负责一个系统的能力，能端到端(end to end)开发一个完整的系统。
> 包含：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。

### 需求分析
> 工程师要具备产品思维，不做完全的“技术控”。

- 首先，当对产品设计无从下手的时候，可以借鉴其他公司的竞品来参考分析。先分析出产品的主要功能点；
- 除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。
- 得到一个非常笼统、粗糙的功能需求。
- 通过 **线框图、用户用例** 来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。
  - 用户用例有点类似于单元测试用例。
  - 侧重情景化，模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。
  - 例如关于积分有效期的用户用例：
    - 用户在获取积分的时候，会告知积分的有效期；
    - 用户在使用积分的时候，会优先使用快过期的积分；
    - 用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；
    - 用户在查询总可用积分的时候，会排除掉过期的积分；
- 罗列功能点

### 系统设计
- 面向对象设计聚焦代码层面（主要是针对类），系统设计聚焦在架构层面（主要是针对模块）。许多设计原则和思想互通。
#### 1. 合理地将功能划分到不同模块
  - 面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。
  - 系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。
  - 针对于前面的积分功能，模块划分的三种方法：
    1. 积分赚取渠道及兑换规则、消费渠道及兑换规则的增删改查，不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责积分的增删改查工作；
    2. 积分赚取渠道及兑换规则、消费渠道及兑换规则的增删改查，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。
    3. 所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。
 - 推荐1、2中划分方法
 - 为了避免业务知识的耦合，**让下层系统更加通用**，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息；**但是**，可以接受上层系统包含下层系统的业务信息。
#### 2. 设计模块与模块之间的交互关系
- 在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。
- 常见的系统交互方式：
  1. **同步接口调用**；好处：简单直接
  2. **利用消息中间件异步调用**；好处：解耦效果更好

- 区分何时使用何种系统及哦啊胡方式：
  - **上下层系统之间** 的调用倾向于通过同步接口；
  - **同层之间** 的调用倾向于异步消息调用；

#### 3. 设计模块的接口、数据库、业务模型
- 业务系统本身的设计无外乎这三方面的工作：
  - 接口设计
  - 数据库设计
  - 业务模型设计

### 业务开发包含的工作
1. 接口设计；
2. 数据库设计；
3. 业务模型设计；

> 数据库和接口的设计非常重要，一单设计好并投入使用之后，这两部分都不能轻易改动。

> 改动数据表结构，需要设计数据的迁移和适配；改动接口需要推动接口的使用者作相应的代码修改。

- 因此我们在设计接口和数据库的时候，一定要多花店心思和时间，切不可过于随意。
- 相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。

#### 1. 针对业务系统，设计数据库

#### 2. 设计业务系统的接口
- 接口设计要符合单一职责原则，粒度越小通用性就越好。
  - *如果粒度太小也会存在问题：*
    - 如果是远程接口调用，调用多次会影响性能；
    - 本该在一个接口中完成的原子性操作，拆分成多个小接口，会涉及分布式事务的数据一致性问题。
  - 兼顾易用性和性能，借鉴`外观模式`，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。

#### 3. 业务模型的设计
- 系统分层
  - Controller 负责接口暴露；
  - Service 负责核心业务逻辑，也就是**业务模型**；
  - Repository 负责数据读写；

- 开发模式
  - 基于贫血模型的传统开发模式（面向过程风格）
    - 应用于业务相对比较简单，功能足够
  - 基于充血模型的 DDD 开发模式（面向对象风格）
    - 应对与复杂的业务系统开发

- 做好代码的模块化和解耦，让业务代码跟其他业务代码之间便捷清晰，没有太多耦合，后期如果需要拆分成独立项目来开发部署，也并不困难。

### 为什么要分 MVC 三层开发
#### 1. 分层能起到代码复用的作用
- 同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多个 Controller 调用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。
#### 2. 分层能起到隔离变化的作用
- 分层提现了一种抽象和封装的设计思想。
- Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。**基于接口而非实现编程的设计思想**，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当需要替换掉数据库的时候，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。
- 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地格力变化。

#### 3. 分层能起到隔离关注点的作用
- 各代码层的职责：
  - Repository 层只关注数据的读写；
  - Service 层只关注业务逻辑，不关注数据来源；
  - Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。
- 三层的关注带你不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。
#### 4. 分层能提高代码的可测试性

#### 5. 分层能应对系统的复杂性
- 当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。
- 拆分有垂直和水平两个方向
  - 水平方向基于业务来做拆分，就是模块化；
  - 垂直方向基于流程来做拆分，就是这里说的分层；

- 不管分层、模块化，还是OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实发挥不了作用。

### BO、VO、Entity 存在的意义
- 每层都会定义相应的数据对象，分别是VO、BO、Entity；
- **推荐：每层定义个字的数据对象。**
  1. VO、BO、Entity 并非完全一样。比如，在 UserEntity 和 UserBO 中定义了 password 字段，但显然不能在 UserVO 中定义 password 字段，否则就把用户密码暴露出去了。
  2. 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。不算违背 DRY 原则。如果合并为一个类，会存在后期因为需求的变化而需要再拆分的问题。
  3. 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。虽然这样的设计稍微有些繁琐，每层都需要定义个字的数据对象，需要做数据对象之间的转化，但是分层清晰。 **对于非常大的项目来说，结构清晰是第一位的。**

#### 如何解决代码重复的问题
- 继承可以解决代码重复问题，我们可以将公共的字段定义到父类中，让VO\BO\Entity 都继承这个父类，各自只定义特有的字段。
- *因为这里的继承层次很浅，也不复杂，并不会影响代码的可读性和可维护性。*

#### 如何解决不同分层之间的数据对象的互相转化
- 手动赋值，一个字段一个字段的赋值
- 利用 BeanUtils 等工具类

#### VO\BO\Entity 都是基于贫血模型，而且为了兼容框架或开发库，需要为每个字段定义 set 方法。这些都违背了 OOP 的封装特性，会导致数据被随意修改。
- Entity 和 VO 的生命周期是有限的，都仅在本层范围内。
- 都是 Repository 和 Controller 层，没有太多业务逻辑，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。
- 但是，BO 就存在风险了，**设计的问题本身就没有最优解，只有权衡。**